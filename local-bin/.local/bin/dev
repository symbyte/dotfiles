#!/bin/bash
# dev - Open a Linear ticket worktree with Claude Code and LazyGit in Zellij
#
# This script:
# 1. Fetches Linear issues and matches them with existing worktrees in ~/projects/wt
# 2. Presents an fzf picker showing issue number and title
# 3. Allows entering a custom session name to create a new worktree
# 4. Creates a Zellij session using the 'dev' layout (~/.config/zellij/layouts/dev.kdl):
#    - nvim with Octo (left pane)
#    - Claude Code (top-right pane) - auto-detects PR status via dev-claude
#    - LazyGit (bottom-right pane)

set -e

WT_DIR="$HOME/projects/wt"
REPO_DIR="$HOME/projects/apricot"
CACHE_FILE="$HOME/.cache/linear-issues.json"
CACHE_MAX_AGE=3600  # 1 hour in seconds

# Fetch Linear issues assigned to me
fetch_linear_issues() {
    if [[ -z "$LINEAR_API_KEY" ]]; then
        return 1
    fi

    curl -s -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: $LINEAR_API_KEY" \
        -d '{"query": "query { viewer { assignedIssues(first: 100) { nodes { identifier title } } } }"}' \
        https://api.linear.app/graphql 2>/dev/null
}

# Get cached or fresh Linear issues
get_linear_issues_cached() {
    mkdir -p "$(dirname "$CACHE_FILE")"

    # Check if cache exists and is fresh
    if [[ -f "$CACHE_FILE" ]]; then
        local cache_age=$(($(date +%s) - $(stat -f%m "$CACHE_FILE" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt $CACHE_MAX_AGE ]]; then
            cat "$CACHE_FILE"
            return 0
        fi
    fi

    # Fetch fresh data
    local data=$(fetch_linear_issues)
    if [[ -n "$data" ]] && echo "$data" | jq -e '.data.viewer.assignedIssues.nodes' &>/dev/null; then
        echo "$data" > "$CACHE_FILE"
        echo "$data"
    elif [[ -f "$CACHE_FILE" ]]; then
        # Use stale cache if fetch failed
        cat "$CACHE_FILE"
    fi
}

# Get worktrees with Linear issue info
get_worktree_issues() {
    local worktrees=$(ls -1 "$WT_DIR" 2>/dev/null | grep -E '^[a-z]+-[0-9]+$' | grep -v '^pr-' || true)

    if [[ -z "$worktrees" ]]; then
        return 0
    fi

    # Try to get Linear issue data
    local linear_data=$(get_linear_issues_cached 2>/dev/null || echo "")

    for wt in $worktrees; do
        local identifier=$(echo "$wt" | tr '[:lower:]' '[:upper:]')
        local title=""

        # Try to get title from Linear data
        if [[ -n "$linear_data" ]]; then
            title=$(echo "$linear_data" | jq -r --arg id "$identifier" \
                '.data.viewer.assignedIssues.nodes[] | select(.identifier == $id) | .title' 2>/dev/null || echo "")
        fi

        if [[ -n "$title" ]]; then
            echo -e "$wt\t$identifier: $title"
        else
            echo -e "$wt\t$identifier"
        fi
    done
}

# Create a new worktree with the given name
create_worktree() {
    local name="$1"
    local wt_path="$WT_DIR/$name"

    if [[ -d "$wt_path" ]]; then
        echo "Worktree already exists: $wt_path" >&2
        return 0
    fi

    echo "Creating worktree '$name' from staging..." >&2

    # Fetch latest
    git -C "$REPO_DIR" fetch --prune --quiet

    # Create worktree with new branch from origin/staging
    git -C "$REPO_DIR" worktree add -b "$name" "$wt_path" origin/staging

    echo "Created worktree at $wt_path" >&2
}

# Check if session exists
session_exists() {
    zellij list-sessions 2>/dev/null | sed 's/\x1b\[[0-9;]*m//g' | grep -q "^${1} "
}

main() {
    local issues=$(get_worktree_issues)

    # Use fzf with --print-query to allow custom input
    local fzf_output
    if [[ -n "$issues" ]]; then
        fzf_output=$(echo "$issues" | fzf \
            --delimiter=$'\t' \
            --with-nth=2 \
            --preview-window=hidden \
            --header='Select worktree or type new session name' \
            --prompt='Session: ' \
            --print-query || true)
    else
        # No existing worktrees - just prompt for input
        fzf_output=$(echo "" | fzf \
            --preview-window=hidden \
            --header='No worktrees found. Type a session name to create one.' \
            --prompt='Session: ' \
            --print-query || true)
    fi

    # fzf --print-query outputs: line 1 = query, line 2 = selected item (if any)
    local query=$(echo "$fzf_output" | sed -n '1p')
    local selected=$(echo "$fzf_output" | sed -n '2p')

    # Determine the session name
    local session_name
    if [[ -n "$selected" ]]; then
        # User selected an existing worktree
        session_name=$(echo "$selected" | cut -f1)
    elif [[ -n "$query" ]]; then
        # User typed a custom name
        session_name="$query"
    else
        # User cancelled
        exit 0
    fi

    local wt_path="$WT_DIR/$session_name"

    # Create worktree if it doesn't exist
    if [[ ! -d "$wt_path" ]]; then
        create_worktree "$session_name"
    fi

    # Open or attach to Zellij session
    cd "$wt_path"

    # Check if node_modules is missing - nvim will trigger pnpm setup via overseer
    if [[ ! -d "$wt_path/node_modules" ]]; then
        export NEEDS_PNPM_SETUP=1
    fi

    if session_exists "$session_name"; then
        zellij attach "$session_name"
    elif [[ -n "$ZELLIJ" ]]; then
        # Inside Zellij - can't create with layout
        zellij attach -c "$session_name"
    else
        # Outside Zellij - create new session with dev layout
        zellij -n dev -s "$session_name"
    fi
}

main "$@"
